"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[855],{3574:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>u,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var n=i(5893),r=i(1151);const s={sidebar_position:5},a="Asynchronous Queries",o={id:"building-applications/async-queries",title:"Asynchronous Queries",description:"Groundlight provides a simple interface for submitting asynchronous queries. This is useful for times in which the thread or process or machine submitting image queries is not the same thread or machine that will be retrieving and using the results. For example, you might have a forward deployed robot or camera that submits image queries to Groundlight, and a separate server that retrieves the results and takes action based on them. We will refer to these two machines as the submitting machine and the retrieving machine.",source:"@site/docs/building-applications/6-async-queries.md",sourceDirName:"building-applications",slug:"/building-applications/async-queries",permalink:"/python-sdk/docs/building-applications/async-queries",draft:!1,unlisted:!1,editUrl:"https://github.com/groundlight/python-sdk/tree/main/docs/docs/building-applications/6-async-queries.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Handling Server Errors",permalink:"/python-sdk/docs/building-applications/handling-errors"},next:{title:"Using Groundlight on the Edge",permalink:"/python-sdk/docs/building-applications/edge"}},u={},d=[{value:"Setup Submitting Machine",id:"setup-submitting-machine",level:2},{value:"Setup Retrieving Machine",id:"setup-retrieving-machine",level:2},{value:"Important Considerations",id:"important-considerations",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"asynchronous-queries",children:"Asynchronous Queries"}),"\n",(0,n.jsxs)(t.p,{children:["Groundlight provides a simple interface for submitting asynchronous queries. This is useful for times in which the thread or process or machine submitting image queries is not the same thread or machine that will be retrieving and using the results. For example, you might have a forward deployed robot or camera that submits image queries to Groundlight, and a separate server that retrieves the results and takes action based on them. We will refer to these two machines as the ",(0,n.jsx)(t.strong,{children:"submitting machine"})," and the ",(0,n.jsx)(t.strong,{children:"retrieving machine"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"setup-submitting-machine",children:"Setup Submitting Machine"}),"\n",(0,n.jsxs)(t.p,{children:["On the ",(0,n.jsx)(t.strong,{children:"submitting machine"}),", you will need to install the Groundlight Python SDK. Then you can submit image queries asynchronously using the ",(0,n.jsx)(t.code,{children:"ask_async"})," interface (read the full documentation ",(0,n.jsx)(t.a,{href:"pathname:///python-sdk/api-reference-docs/#groundlight.client.Groundlight.ask_async",children:"here"}),"). ",(0,n.jsx)(t.code,{children:"ask_async"})," submits your query and returns as soon as the query is submitted. It does not wait for an answer to be available prior to returning to minimize the time your program spends interacting with Groundlight. As a result, the ",(0,n.jsx)(t.code,{children:"ImageQuery"})," object ",(0,n.jsx)(t.code,{children:"ask_async"})," returns lacks a ",(0,n.jsx)(t.code,{children:"result"})," (the ",(0,n.jsx)(t.code,{children:"result"})," field will be ",(0,n.jsx)(t.code,{children:"None"}),"). This is acceptable for this use case as the ",(0,n.jsx)(t.strong,{children:"submitting machine"})," is not interested in the result. Instead, the ",(0,n.jsx)(t.strong,{children:"submitting machine"})," just needs to communicate the ",(0,n.jsx)(t.code,{children:"ImageQuery.id"}),"s to the ",(0,n.jsx)(t.strong,{children:"retrieving machine"})," - this might be done via a database, a message queue, or some other mechanism. For this example, we assume you are using a database where you save the ",(0,n.jsx)(t.code,{children:"ImageQuery.id"})," to it via ",(0,n.jsx)(t.code,{children:"db.save(image_query.id)"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",metastring:"notest",children:'from groundlight import Groundlight\nimport cv2\nfrom time import sleep\n\ndetector = gl.get_or_create_detector(name="your_detector_name", query="your_query")\n\ncam = cv2.VideoCapture(0)  # Initialize camera (0 is the default index)\n\nwhile True:\n    _, image = cam.read()  # Capture one frame from the camera\n    image_query = gl.ask_async(detector=detector, image=image)  # Submit the frame to Groundlight\n    db.save(image_query.id)  # Save the image_query.id to a database for the retrieving machine to use\n    sleep(10) # Sleep for 10 seconds before submitting the next query\n\ncam.release()  # Release the camera\n\n'})}),"\n",(0,n.jsx)(t.h2,{id:"setup-retrieving-machine",children:"Setup Retrieving Machine"}),"\n",(0,n.jsxs)(t.p,{children:["On the ",(0,n.jsx)(t.strong,{children:"retrieving machine"})," you will need to install the Groundlight Python SDK. Then you can retrieve the results of the image queries submitted by another machine using ",(0,n.jsx)(t.code,{children:"get_image_query"}),". The ",(0,n.jsx)(t.strong,{children:"retrieving machine"})," can then use the ",(0,n.jsx)(t.code,{children:"ImageQuery.result"})," to take action based on the result for whatever application you are building. For this example, we assume your application looks up the next image query to process from a database via ",(0,n.jsx)(t.code,{children:"db.get_next_image_query_id()"})," and that this function returns ",(0,n.jsx)(t.code,{children:"None"})," once all ",(0,n.jsx)(t.code,{children:"ImageQuery"}),"s are processed."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",metastring:"notest",children:"from groundlight import Groundlight\n\ndetector = gl.get_or_create_detector(name=\"your_detector_name\", query=\"your_query\")\n\nimage_query_id = db.get_next_image_query_id()\n\nwhile image_query_id is not None:\n    image_query = gl.get_image_query(id=image_query_id) # retrieve the image query from Groundlight\n    result = image_query.result\n\n    # take action based on the result of the image query\n    if result.label == 'YES':\n        pass # TODO: do something based on your application\n    elif result.label == 'NO':\n        pass # TODO: do something based on your application\n    elif result.label == 'UNCLEAR':\n        pass # TODO: do something based on your application\n\n    # update image_query_id for next iteration of the loop\n    image_query_id = db.get_next_image_query_id()\n"})}),"\n",(0,n.jsx)(t.h2,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,n.jsxs)(t.p,{children:["When you submit an image query asynchronously, ML prediction on your query is ",(0,n.jsx)(t.strong,{children:"not"})," instant. So attempting to retrieve the result immediately after submitting an async query will likely result in an ",(0,n.jsx)(t.code,{children:"UNCLEAR"})," result as Groundlight is still processing your query. Instead, if your code needs a ",(0,n.jsx)(t.code,{children:"result"})," synchronously we recommend using one of our methods with a polling mechanism to retrieve the result. You can see all of the interfaces available in the documentation ",(0,n.jsx)(t.a,{href:"pathname:///python-sdk/api-reference-docs/#groundlight.client.Groundlight",children:"here"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",metastring:"notest",children:'from groundlight import Groundlight\nfrom PIL import Image\n\ndetector = gl.get_or_create_detector(name="your_detector_name", query="your_query")\nimage = Image.open("/path/to/your/image.jpg")\nimage_query = gl.ask_async(detector=detector, image=image)  # Submit async query to Groundlight\nresult = image_query.result  # This will always be \'None\' as you asked asynchronously\n\nimage_query = gl.get_image_query(id=image_query.id)  # Immediately retrieve the image query from Groundlight\nresult = image_query.result  # This will likely be \'UNCLEAR\' as Groundlight is still processing your query\n\nimage_query = gl.wait_for_confident_result(id=image_query.id)  # Poll for a confident result from Groundlight\nresult = image_query.result\n'})})]})}function c(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},1151:(e,t,i)=>{i.d(t,{Z:()=>o,a:()=>a});var n=i(7294);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);