"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[7734],{446:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var n=i(4848),s=i(8453);const a={title:"The Grime Guardian: Building Stateful Multi-camera applications with Groundlight",slug:"grime-guardian",authors:[{name:"Sunil Kumar",title:"Machine Learning Engineer",image_url:"https://a-us.storyblok.com/f/1015187/1000x1000/a265e322bd/kumars.jpg"}],tags:["Groundlight Python SDK","Raspberry Pi","Multithreading","State Management"],image:"./images/grime_guardian/gg_pfp.png",hide_table_of_contents:!1},o=void 0,r={permalink:"/python-sdk/blog/grime-guardian",editUrl:"https://github.com/groundlight/python-sdk/tree/main/docs/blog/blog/2024-02-01-grime-guardian.md",source:"@site/blog/2024-02-01-grime-guardian.md",title:"The Grime Guardian: Building Stateful Multi-camera applications with Groundlight",description:"Groundlight has a Problem",date:"2024-02-01T00:00:00.000Z",formattedDate:"February 1, 2024",tags:[{label:"Groundlight Python SDK",permalink:"/python-sdk/blog/tags/groundlight-python-sdk"},{label:"Raspberry Pi",permalink:"/python-sdk/blog/tags/raspberry-pi"},{label:"Multithreading",permalink:"/python-sdk/blog/tags/multithreading"},{label:"State Management",permalink:"/python-sdk/blog/tags/state-management"}],readingTime:10.895,hasTruncateMarker:!0,authors:[{name:"Sunil Kumar",title:"Machine Learning Engineer",image_url:"https://a-us.storyblok.com/f/1015187/1000x1000/a265e322bd/kumars.jpg",imageURL:"https://a-us.storyblok.com/f/1015187/1000x1000/a265e322bd/kumars.jpg"}],frontMatter:{title:"The Grime Guardian: Building Stateful Multi-camera applications with Groundlight",slug:"grime-guardian",authors:[{name:"Sunil Kumar",title:"Machine Learning Engineer",image_url:"https://a-us.storyblok.com/f/1015187/1000x1000/a265e322bd/kumars.jpg",imageURL:"https://a-us.storyblok.com/f/1015187/1000x1000/a265e322bd/kumars.jpg"}],tags:["Groundlight Python SDK","Raspberry Pi","Multithreading","State Management"],image:"./images/grime_guardian/gg_pfp.png",hide_table_of_contents:!1},unlisted:!1,nextItem:{title:"Tales from the Binomial Tail: Confidence intervals for balanced accuracy",permalink:"/python-sdk/blog/confidence-intervals-for-balanced-accuracy"}},h={image:i(6485).A,authorsImageUrls:[void 0]},l=[{value:"Groundlight has a Problem",id:"groundlight-has-a-problem",level:2},{value:"Overview of the Application - The Grime Guardian",id:"overview-of-the-application---the-grime-guardian",level:2},{value:"Architecture of a Sophisticated Groundlight Application",id:"architecture-of-a-sophisticated-groundlight-application",level:2},{value:"Microservice-like Architecture",id:"microservice-like-architecture",level:2},{value:"State Management and Notification Logic",id:"state-management-and-notification-logic",level:2},{value:"Discord Bot Notifications",id:"discord-bot-notifications",level:2},{value:"Future Improvements and Enhancements",id:"future-improvements-and-enhancements",level:2},{value:"Build Your Own Grime Guardian",id:"build-your-own-grime-guardian",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"groundlight-has-a-problem",children:"Groundlight has a Problem"}),"\n",(0,n.jsx)(t.p,{children:"Here at the Groundlight office we have a bit of a problem - sometimes we leave dirty dishes in the office sink. They pile up, and as the pile grows it becomes more and more tempting to simply add to the pile instead of cleaning it up. It was clear that the Groundlight office needed a \u201cgrime guardian\u201d to save us from our messy selves. One day, I realized that this was the perfect problem to solve using Groundlight\u2019s computer vision SDK. I could focus on developing the complex embedded application logic while Groundlight handled the computer vision. My design provided me with an opportunity to test out a handful of interesting design patterns, including deployment on a Raspberry Pi, multi-camera and multi-detector usage, a microservice-like architecture achieved via multithreading, and complex state handling."}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("img",{src:i(7891).A}),(0,n.jsx)("figcaption",{children:(0,n.jsx)("small",{children:(0,n.jsx)(t.p,{children:"The Groundlight office sink, where dishes accumulate faster than git commits."})})})]}),"\n",(0,n.jsx)(t.h2,{id:"overview-of-the-application---the-grime-guardian",children:"Overview of the Application - The Grime Guardian"}),"\n",(0,n.jsxs)(t.p,{children:["The application I developed, the ",(0,n.jsx)(t.strong,{children:"Grime Guardian"}),", is designed to make it fun for the Groundlight team to clean up dishes that have been abandoned in the sink (",(0,n.jsx)(t.a,{href:"https://github.com/sunildkumar/GrimeGuardian",children:"source code"}),"). Using two cameras, the application monitors the state of the office sink and the overall kitchen scene. If it recognizes that dirty dishes were left in the sink for over a minute, it posts a funny yet inspiring message and photo to a Discord server that alerts the Groundlight team and encourages someone to help. Then, while the dishes remain unattended it surveys the kitchen until it sees someone. Once someone comes to help, it posts a message and photo, celebrating them as a hero, giving everyone in the Discord server a chance to recognize them. While this is cheesy, it has made it a bit more fun for us to do the dishes!"]}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("img",{src:i(5113).A}),(0,n.jsx)("figcaption",{children:(0,n.jsx)("small",{children:(0,n.jsx)(t.p,{children:"The Grime Guardian alerting the Groundlight Team through Discord"})})})]}),"\n",(0,n.jsx)(t.h2,{id:"architecture-of-a-sophisticated-groundlight-application",children:"Architecture of a Sophisticated Groundlight Application"}),"\n",(0,n.jsx)(t.p,{children:"The Grime Guardian demonstrates how to build an advanced Groundlight application in a handful of ways:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Raspberry Pi Deployment"})," - The Grime Guardian leverages our custom ",(0,n.jsx)(t.a,{href:"https://github.com/groundlight/groundlight-pi-gen",children:"Raspberry Pi Image"}),", which makes it easy to deploy Groundlight applications on Raspberry Pi."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Multiple Cameras"})," - The Grime Guardian actively uses more than one camera to solve a problem (it has one camera pointed at the sink and one pointed at the general kitchen scene)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Multiple Detectors"})," - The Grime Guardian combines multiple Groundlight detectors to solve a problem."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Microservice-like architecture via Multithreading"})," - The Grime Guardian\u2019s architecture is broken down into a handful of microservice-like processes - each running in a different thread on the same machine. This improves the app\u2019s robustness and allows for more flexibility and scalability."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Complex State"})," - As described in the previous section, the state of the world this app is tracking is somewhat complex. In addition to knowing the state of the sink and kitchen, the app tracks how recently the state was updated and how recently it has sent a notification to the Groundlight team."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Discord Bot Integration/Notifications"})," - The Grime Guardian uses the Discord Bot API to send notifications to a Discord server. Discord can be an extremely powerful and flexible tool for building applications (e.g. Midjourney)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Robustness"})," - In practice, the Grime Guardian has been extremely robust, with only one or two incorrect (false positive) notifications over many weeks of deployment and hundreds of thousands of Groundlight queries."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"microservice-like-architecture",children:"Microservice-like Architecture"}),"\n",(0,n.jsx)(t.p,{children:"The Grime Guardian leverages a microservice-like architecture via multithreading to enhance its performance and robustness. Each microservice within the application runs in its own thread on a single Raspberry Pi, allowing for simultaneous execution of tasks. This architecture is particularly beneficial in this context as it allows the application to monitor the sink and the kitchen scene concurrently using two cameras, and to process the data from these cameras independently. Furthermore, it enables the application to manage complex state tracking and Discord notifications without blocking or slowing down the image processing tasks."}),"\n",(0,n.jsx)(t.p,{children:"The application is broken into six microservices:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Sink Image Capturer"}),": This microservice captures images from a camera pointed at the sink and submits them as queries to a Groundlight detector via the ",(0,n.jsx)(t.code,{children:"ask_async"}),' SDK method (this method is useful for times in which the thread submitting image queries is not the same thread that will be retrieving and using the results). I set the detector\'s query to "Is there at least one dish in the sink? Cleaning supplies like a sponge, brush, soap, etc. are not considered dishes. If you cannot see into the sink, consider it empty and answer NO" and set the confidence threshold to 75%. After Groundlight replies with a query ID, the service passes the query ID to the ',(0,n.jsx)(t.strong,{children:"Query Processor"})," service."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Kitchen Image Capturer"}),": This microservice is identical to the ",(0,n.jsx)(t.strong,{children:"Sink Image Capturer"}),' except it uses the camera that can view the whole kitchen and submits images to a detector with the query "Is there at least one person in this image?" and set the confidence threshold to 75% as well.']}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Query Processor"}),": This microservice processes the queries passed to it by the two ",(0,n.jsx)(t.strong,{children:"Capturer"})," services, waiting for confident answers from Groundlight and filtering out queries that do not become confident within a reasonable time (I chose a 10 second timeout as that was how frequently each ",(0,n.jsx)(t.strong,{children:"Capturer"})," service submitted a query to Groundlight). Queries that become confident are passed to the ",(0,n.jsx)(t.strong,{children:"State Updater"})," service."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"State Updater"}),": This microservice updates a complex model of the application's state based on Groundlight's responses. It tracks the status and last update time of the sink and kitchen, the image query IDs that led to the current state, and the timestamps of the last clean sink and notifications sent."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Notification Publisher"}),": This microservice listens for updates to the state of the application (written by the ",(0,n.jsx)(t.strong,{children:"State Updater"}),") and decides whether it is appropriate to send one of two possible notifications. If a notification is needed, it adds it to a queue of notifications to be processed by the ",(0,n.jsx)(t.strong,{children:"Discord Bot"}),". Importantly, the ",(0,n.jsx)(t.strong,{children:"Notification Publisher"})," only determines if a notification should be sent. It does not handle the mechanics of what data to send or how and where to send it."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Discord Bot"}),": This microservice runs a Discord bot, which listens for requests from the ",(0,n.jsx)(t.strong,{children:"Notification Publisher"}),". When a request arrives, the bot collects the relevant data and sends notifications to a Discord server."]}),"\n"]}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("img",{src:i(3386).A}),(0,n.jsx)("figcaption",{children:(0,n.jsx)("small",{children:(0,n.jsxs)(t.p,{children:[(0,n.jsx)("small",{children:"Diagram created by Jared Randall"}),(0,n.jsx)("br",{}),"Architecture diagram for the application"]})})})]}),"\n",(0,n.jsx)(t.h2,{id:"state-management-and-notification-logic",children:"State Management and Notification Logic"}),"\n",(0,n.jsx)(t.p,{children:"The Grime Guardian's ability to track and manage a complex state is a cornerstone of its functionality. The application not only needs to know the current state of the sink and kitchen but also when these states were last updated and when the last notifications were sent. In total, the application needs nine separate variables to function properly (a combination of binary-encoded state fields, timestamps, and image query IDs).  This level of detail is crucial for avoiding redundant alerts and ensuring timely and accurate updates."}),"\n",(0,n.jsx)(t.p,{children:"As seen in the architecture diagram in the previous section, multiple services read and write to the state simultaneously. To handle this complexity, I implemented a wrapper around the state to handle reads and writes in a thread safe manner. This wrapper ensures the state can be accessed and modified safely across many services. It uses a lock to prevent race conditions, ensuring that only one thread can modify the state at a time."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:"import threading\nimport copy\n\n# simplified version of how the Grime Guardian manages state safely\nclass SimpleThreadSafeState:\n    def __init__(self):\n        self.state = False\n        self.lock = threading.Lock()\n\n    def update_state(self, new_state: bool):\n        with self.lock:\n            self.state = new_state\n\n    def get_state(self) -> bool:\n        with self.lock:\n            return copy.copy(self.state)\n"})}),"\n",(0,n.jsx)(t.p,{children:"The application uses this state to determine when to send notifications. I've tried to break down this logic into a few of flowcharts. At a high level, the logic is pretty simple. Whenever the the application's state is updated, the application performs a check to determine if the new state justifies sending each type of notification."}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("img",{src:i(817).A}),(0,n.jsx)("figcaption",{children:(0,n.jsx)("small",{children:(0,n.jsxs)(t.p,{children:[(0,n.jsx)("small",{children:"Diagram created by Jared Randall"}),(0,n.jsx)("br",{}),"High level flow for determining if a notification should be sent"]})})})]}),"\n",(0,n.jsx)(t.p,{children:"The logic for determining if each notification should be sent is a bit more complex. It first checks for the last time a notification was sent. If the last notification was sent in the last 5 minutes, no notification is sent. This is important as it prevents the application from spamming the Discord server with notifications. Next, the application checks if the sink currently has dirty dishes in it, and how long it has been since the sink was empty. We only send the notification if dirty dishes have been present for more than a minute. This approach ensures that the Grime Guardian does not send a notification every time someone puts a dirty dish in the sink, but only when dishes have been abandoned for a while. This ensures that the app only notifies the team when it is actually needed."}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("img",{src:i(2412).A}),(0,n.jsx)("figcaption",{children:(0,n.jsx)("small",{children:(0,n.jsxs)(t.p,{children:[(0,n.jsx)("small",{children:"Diagram created by Jared Randall"}),(0,n.jsx)("br",{})," Flow for determining if the dirty dishes notification should be sent"]})})})]}),"\n",(0,n.jsx)(t.p,{children:"The logic for determining if someone has arrived to help is similar. We have a check that ensures we do not spam the Discord server. Then, we only send a notification if there are currently dishes in the sink and someone is present in the kitchen. This ensures that the Grime Guardian does not send a notification every time someone walks into the kitchen, but only when dishes are in the sink."}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("img",{src:i(4627).A}),(0,n.jsx)("figcaption",{children:(0,n.jsx)("small",{children:(0,n.jsxs)(t.p,{children:[(0,n.jsx)("small",{children:"Diagram created by Jared Randall"}),(0,n.jsx)("br",{})," Flow for determining if the help arrived notification should be sent"]})})})]}),"\n",(0,n.jsx)(t.p,{children:'In retrospect, getting the notification logic to work properly was one of the more challenging parts of this project. The version I presented here is the result of many iterations and tweaks based on real world usage and results. I think this is because this logic is an expression of the application\'s core value proposition. If this "business logic" is not correct, the application will not be fun or useful. Fortunately, Groundlight enabled me to focus on this logic and not worry about the computer vision.'}),"\n",(0,n.jsx)(t.h2,{id:"discord-bot-notifications",children:"Discord Bot Notifications"}),"\n",(0,n.jsxs)(t.p,{children:["The Grime Guardian uses the ",(0,n.jsx)(t.a,{href:"https://discord.com/developers/docs/intro",children:"Discord Bot API"})," to send notifications to a Discord server I set up. At startup, Discord requires some boilerplate to handle authentication. After this is done, the bot listens for new notification requests from the ",(0,n.jsx)(t.strong,{children:"Notification Publisher"}),". Based on the type of request, the bot collects the relevant information (e.g. the image of the dirty sink, or the person doing the dishes) and sends the message. The Discord Bot API makes this incredibly simple, after handling authentication, a new message and an attached image can be sent in a single line."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'await channel.send("message", file=discord.File(fpath))\n'})}),"\n",(0,n.jsx)(t.p,{children:"While I did not have time to add more complexity to the bot, Discord\u2019s strong documentation gives me confidence it would not be that hard to add more features. For example, it would have been nice if the bot could listen for replies or emote reactions to its notifications - if the bot reported that the sink was full of dishes when really it was not, I could react to the notification with an emote that indicates the correct label for the image, and then the bot could automatically send this information to Groundlight, improving ML performance."}),"\n",(0,n.jsx)(t.h2,{id:"future-improvements-and-enhancements",children:"Future Improvements and Enhancements"}),"\n",(0,n.jsxs)(t.p,{children:["Extending the functionality of the application, I can imagine adding motion detection to limit the frequency of image submissions to Groundlight. Currently, the application sends images to Groundlight at a fixed interval (every 10 seconds), regardless of whether there has been any significant change in the scene. This approach, while simple, could be optimized to become more cost effective. As it is now, it can lead to unnecessary image submissions when the scene is static. By incorporating motion detection, the application could intelligently decide when to send images to Groundlight. Fortunately, some of my excellent colleagues have built ",(0,n.jsx)(t.a,{href:"https://github.com/groundlight/framegrab/",children:(0,n.jsx)(t.code,{children:"framegrab"})}),", an open source tool that automatically handles this."]}),"\n",(0,n.jsx)(t.h2,{id:"build-your-own-grime-guardian",children:"Build Your Own Grime Guardian"}),"\n",(0,n.jsxs)(t.p,{children:["Thank you for taking the time to read my post! As I reflect back, I\u2019m very proud of how Groundlight enabled me to very quickly and effortlessly stand up an ML solution to solve a simple office problem in a fun and engaging way! If you are particularly interested or inspired, I encourage you to check out the ",(0,n.jsx)(t.a,{href:"https://github.com/sunildkumar/GrimeGuardian",children:"source code"}),". Feel free to open a GitHub issue with questions or submit a PR with improvements!"]}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("img",{src:i(9291).A}),(0,n.jsx)("figcaption",{children:(0,n.jsx)("small",{children:(0,n.jsx)(t.p,{children:"The Grime Guardian celebrates Tom, my colleague, for his heroic cleaning effort. The grime is no match for his dish-defeating determination!"})})})]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},6485:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/gg_pfp-ffa4c07d6685865bf0165427946f42b0.png"},3386:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/gg_arch_flow-293787a330013e3e0ac1bf378a333c9e.png"},7891:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/gg_dirty_sink-1d11fc1f7aec8e358cfaf5db73216632.jpg"},5113:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/gg_dirty_sink_notification-483bb0c49da0a6966de7fe79cafd708d.png"},2412:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/gg_dishes_notification_flow-2cb76e1aef6d5f040817c33364b9260a.png"},4627:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/gg_help_arrived_flow-7bcfe14e030537866c6bd15daebd6115.png"},9291:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/gg_hero_notification-eaffe18fcd64c4f75d6e6db50e237033.png"},817:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/gg_notification_flow-af7366a7a2053313d95868c8043115ee.png"},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var n=i(6540);const s={},a=n.createContext(s);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);